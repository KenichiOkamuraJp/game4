<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue.js ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³RPG</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #00ff00;
            margin: 0;
            padding: 20px;
        }
        
        .game-container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #001a00;
            border: 2px solid #00ff00;
            padding: 20px;
            border-radius: 10px;
        }
        
        .title {
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
            color: #ffff00;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .character-creation {
            text-align: center;
        }
        
        .stat-display {
            display: inline-block;
            margin: 10px;
            padding: 10px;
            border: 1px solid #00ff00;
            border-radius: 5px;
        }
        
        .dungeon-view {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .map-container {
            flex: 1;
        }
        
        .dungeon-map {
            display: grid;
            grid-template-columns: repeat(5, 40px);
            gap: 1px;
            border: 2px solid #00ff00;
            padding: 10px;
            background-color: #000;
            margin: 0 auto;
        }
        
        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }
        
        .wall { background-color: #333; }
        .floor { background-color: #002200; }
        .player { background-color: #0066ff; color: white; }
        .enemy { background-color: #ff0000; color: white; }
        .goal { background-color: #ffff00; color: black; }
        .unknown { background-color: #111; color: #444; }
        .visited { background-color: #001100; color: #666; }
        .door-closed { background-color: #8B4513; color: #DEB887; }
        .door-open { background-color: #654321; color: #8B4513; }
        .door-locked { background-color: #8B0000; color: #FFD700; }
        .treasure-chest { background-color: #DAA520; color: #8B4513; }
        .treasure-opened { background-color: #CD853F; color: #654321; }
        .stairs-up { background-color: #4169E1; color: white; }
        .stairs-down { background-color: #8A2BE2; color: white; }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .control-btn {
            background-color: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 5px;
        }
        
        .control-btn:hover {
            background-color: #006600;
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .status-panel {
            min-width: 250px;
            background-color: #000;
            border: 2px solid #00ff00;
            padding: 15px;
            border-radius: 5px;
        }
        
        .message-log {
            height: 200px;
            overflow-y: auto;
            background-color: #001100;
            border: 1px solid #00ff00;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .combat-screen, .game-over-screen {
            text-align: center;
            padding: 20px;
            border: 2px solid #ff0000;
            background-color: #330000;
            border-radius: 10px;
        }
        
        .input-field {
            background-color: #001100;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 8px;
            margin: 5px;
            font-family: inherit;
            border-radius: 3px;
        }
        
        .victory-screen {
            text-align: center;
            color: #ffff00;
            font-size: 18px;
            padding: 20px;
            border: 3px solid #ffff00;
            background-color: #333300;
            border-radius: 10px;
        }
        
        .town-screen {
            text-align: center;
            padding: 20px;
        }
        
        .town-menu {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .town-panel, .guild-panel {
            background-color: #001a00;
            border: 2px solid #00ff00;
            padding: 20px;
            border-radius: 10px;
            min-width: 200px;
        }
        
        .guild-panel {
            margin: 20px auto;
            max-width: 500px;
        }
        
        .level-up-screen {
            background-color: #003300;
            border: 2px solid #ffff00;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .action-section {
            margin: 10px 0;
            padding: 10px 0;
            border-top: 1px solid #00ff00;
        }
        
        .action-section:first-child {
            border-top: none;
        }
        
        .disabled-text {
            color: #666;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .highlight-text {
            color: #ffff00;
            font-size: 12px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="game-container">
            <h1 class="title">ğŸ° ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¯ã‚¨ã‚¹ãƒˆ ğŸ°</h1>
            
            <!-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½œæˆç”»é¢ -->
            <div v-if="gameState === 'character-creation'" class="character-creation">
                <h2>ğŸ§™â€â™‚ï¸ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½œæˆ</h2>
                <div>
                    <label>åå‰: </label>
                    <input v-model="character.name" class="input-field" placeholder="å†’é™ºè€…ã®åå‰">
                </div>
                <br>
                <div class="stat-display">
                    <strong>èƒ½åŠ›å€¤</strong><br>
                    HP: {{ character.hp }}/{{ character.maxHp }}<br>
                    æ”»æ’ƒåŠ›: {{ character.attack }}<br>
                    é˜²å¾¡åŠ›: {{ character.defense }}
                </div>
                <br>
                <button @click="rollStats" class="control-btn">ğŸ² èƒ½åŠ›å€¤ã‚’æŒ¯ã‚Šç›´ã™</button>
                <button @click="startGame" :disabled="!character.name" class="control-btn">âš”ï¸ å†’é™ºé–‹å§‹</button>
            </div>
            
            <!-- ç”ºç”»é¢ -->
            <div v-if="gameState === 'town'" class="town-screen">
                <h2>ğŸ˜ï¸ å†’é™ºè€…ã®ç”º</h2>
                <p>ã‚ˆã†ã“ãã€{{ character.name }}ã•ã‚“ï¼</p>
                
                <div class="town-menu">
                    <div class="town-panel">
                        <h3>ğŸ“Š ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h3>
                        <div>ãƒ¬ãƒ™ãƒ«: {{ character.level }}</div>
                        <div>EXP: {{ character.exp }} / {{ character.expToNext }}</div>
                        <div>HP: {{ character.hp }} / {{ character.maxHp }}</div>
                        <div>æ”»æ’ƒåŠ›: {{ character.attack }}</div>
                        <div>é˜²å¾¡åŠ›: {{ character.defense }}</div>
                        <div>ğŸ’° æ‰€æŒé‡‘: {{ character.gold }}G</div>
                    </div>
                    
                    <div class="town-panel">
                        <h3>ğŸ¥ å›å¾©ã®æ³‰</h3>
                        <p>ç–²ã‚ŒãŸå†’é™ºè€…ã‚’ç™’ã—ã¾ã™</p>
                        <button @click="fullHeal" :disabled="!canFullHeal" class="control-btn">
                            ğŸ’Š å®Œå…¨å›å¾© ({{ HEAL_COST }}G)
                        </button>
                        <div v-if="character.hp >= character.maxHp" class="disabled-text">
                            ã™ã§ã«æº€ã‚¿ãƒ³ã§ã™
                        </div>
                    </div>
                    
                    <div class="town-panel">
                        <h3>ğŸ“ å†’é™ºè€…ã‚®ãƒ«ãƒ‰</h3>
                        <p>çµŒé¨“ã‚’ç©ã‚“ã§å¼·ããªã‚ã†</p>
                        <button @click="enterGuild" class="control-btn">
                            ğŸ“š ã‚®ãƒ«ãƒ‰ã«å…¥ã‚‹
                        </button>
                        <div v-if="canLevelUp" class="highlight-text">
                            â­ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—å¯èƒ½ï¼
                        </div>
                    </div>
                </div>
                
                <div class="town-panel" style="margin: 20px auto; max-width: 400px;">
                    <h3>ğŸ° ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³</h3>
                    <p>å±é™ºãªãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ãŒç™ºè¦‹ã•ã‚Œã¾ã—ãŸï¼</p>
                    <p><strong>å ±é…¬:</strong> {{ DUNGEON_REWARDS.gold }}G + {{ DUNGEON_REWARDS.exp }}EXP</p>
                    <button @click="enterDungeon" class="control-btn">
                        âš”ï¸ ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã«æŒ‘æˆ¦
                    </button>
                </div>
            </div>
            
            <!-- ã‚®ãƒ«ãƒ‰ç”»é¢ -->
            <div v-if="gameState === 'guild'" class="town-screen">
                <h2>ğŸ“ å†’é™ºè€…ã‚®ãƒ«ãƒ‰</h2>
                <p>ã“ã“ã§ã¯è“„ç©ã—ãŸçµŒé¨“å€¤ã‚’ä½¿ã£ã¦ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§ãã¾ã™</p>
                
                <div class="guild-panel">
                    <h3>ğŸ“Š ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h3>
                    <div>{{ character.name }} (ãƒ¬ãƒ™ãƒ« {{ character.level }})</div>
                    <div>EXP: {{ character.exp }} / {{ character.expToNext }}</div>
                    <div>HP: {{ character.maxHp }}</div>
                    <div>æ”»æ’ƒåŠ›: {{ character.attack }}</div>
                    <div>é˜²å¾¡åŠ›: {{ character.defense }}</div>
                    
                    <div style="margin: 20px 0;">
                        <button v-if="canLevelUp" @click="levelUp" class="control-btn">
                            â¬†ï¸ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼
                        </button>
                        <div v-else class="disabled-text">
                            ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«ã¯ ã‚ã¨ {{ expNeeded }}EXP å¿…è¦ã§ã™
                        </div>
                    </div>
                    
                    <button @click="leaveGuild" class="control-btn">
                        ğŸ˜ï¸ ç”ºã«æˆ»ã‚‹
                    </button>
                </div>
                
                <div v-if="levelUpMessage" class="level-up-screen">
                    <h3>ğŸ‰ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼</h3>
                    <p style="white-space: pre-line;">{{ levelUpMessage }}</p>
                    <button @click="levelUpMessage = ''" class="control-btn">OK</button>
                </div>
            </div>
            
            <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
            <div v-if="gameState === 'playing'" class="dungeon-view">
                <div class="map-container">
                    <div class="dungeon-map">
                        <div v-for="(cell, index) in mapDisplay" :key="index" 
                             :class="['cell', getCellClass(cell)]">
                            {{ getCellSymbol(cell) }}
                        </div>
                    </div>
                    <div class="controls">
                        <div>
                            <button @click="move('up')" class="control-btn">â¬†ï¸ åŒ—</button>
                        </div>
                        <div>
                            <button @click="move('left')" class="control-btn">â¬…ï¸ è¥¿</button>
                            <button @click="move('down')" class="control-btn">â¬‡ï¸ å—</button>
                            <button @click="move('right')" class="control-btn">â¡ï¸ æ±</button>
                        </div>
                    </div>
                </div>
                
                <div class="status-panel">
                    <h3>{{ character.name }} ã®çŠ¶æ…‹</h3>
                    <div><strong>ğŸ° {{ currentFloor }}éš</strong></div>
                    <div>HP: {{ character.hp }}/{{ character.maxHp }}</div>
                    <div>æ”»æ’ƒåŠ›: {{ character.attack }}</div>
                    <div>ä½ç½®: ({{ playerX }}, {{ playerY }})</div>
                    <div>ğŸ—ï¸ éµ: {{ keys }}å€‹</div>
                    
                    <div class="message-log">
                        <div v-for="(message, index) in messages" :key="index">
                            {{ message }}
                        </div>
                    </div>
                    
                    <button @click="usePotion" :disabled="!canUsePotion" class="control-btn">
                        ğŸ§ª å›å¾©è–¬ ({{ potions }}å€‹)
                    </button>
                    
                    <!-- éšæ®µãƒœã‚¿ãƒ³ -->
                    <div v-if="adjacentStairs" class="action-section">
                        <div style="text-align: center;">
                            <button @click="useStairs" class="control-btn">
                                {{ getStairsButtonText() }}
                            </button>
                        </div>
                    </div>
                    
                    <!-- æ‰‰ãƒœã‚¿ãƒ³ -->
                    <div v-if="adjacentDoor" class="action-section">
                        <div style="text-align: center;">
                            <button v-if="!adjacentDoor.isOpen && !adjacentDoor.isLocked" @click="openDoor" class="control-btn">
                                ğŸšª æ‰‰ã‚’é–‹ã‘ã‚‹
                            </button>
                            <button v-if="!adjacentDoor.isOpen && adjacentDoor.isLocked && keys > 0" @click="unlockDoor" class="control-btn">
                                ğŸ—ï¸ éµã§æ‰‰ã‚’é–‹ã‘ã‚‹
                            </button>
                            <button v-if="!adjacentDoor.isOpen && adjacentDoor.isLocked && keys === 0" disabled class="control-btn">
                                ğŸ—ï¸ éµãŒå¿…è¦ã§ã™
                            </button>
                        </div>
                    </div>
                    
                    <!-- å®ç®±ãƒœã‚¿ãƒ³ -->
                    <div v-if="adjacentChest" class="action-section">
                        <div style="text-align: center;">
                            <button v-if="!adjacentChest.isOpened" @click="openChest" class="control-btn">
                                ğŸ“¦ å®ç®±ã‚’é–‹ã‘ã‚‹
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æˆ¦é—˜ç”»é¢ -->
            <div v-if="gameState === 'combat'" class="combat-screen">
                <h2>âš”ï¸ æˆ¦é—˜ï¼</h2>
                <div>
                    <strong>{{ currentEnemy.name }}</strong><br>
                    HP: {{ currentEnemy.hp }}/{{ currentEnemy.maxHp }}
                </div>
                <br>
                <div>
                    <strong>{{ character.name }}</strong><br>
                    HP: {{ character.hp }}/{{ character.maxHp }}
                </div>
                <br>
                <button @click="attack" class="control-btn">âš”ï¸ æ”»æ’ƒ</button>
                <button @click="flee" class="control-btn">ğŸƒ é€ƒã’ã‚‹</button>
            </div>
            
            <!-- å‹åˆ©ç”»é¢ -->
            <div v-if="gameState === 'victory'" class="victory-screen">
                <h2>ğŸ† ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³æ”»ç•¥æˆåŠŸï¼ ğŸ†</h2>
                <p>{{ character.name }}ã¯è¦‹äº‹ã«ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚’æ”»ç•¥ã—ã¾ã—ãŸï¼</p>
                <div style="margin: 20px 0;">
                    <p><strong>ğŸ“¦ ç²å¾—å ±é…¬:</strong></p>
                    <p>ğŸ’° {{ lastReward.gold }}G ã‚’ç²å¾—ï¼</p>
                    <p>â­ {{ lastReward.exp }}EXP ã‚’ç²å¾—ï¼</p>
                </div>
                <button @click="returnToTown" class="control-btn">ğŸ˜ï¸ ç”ºã«æˆ»ã‚‹</button>
            </div>
            
            <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ -->
            <div v-if="gameState === 'game-over'" class="game-over-screen">
                <h2>ğŸ’€ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ ğŸ’€</h2>
                <p>{{ character.name }}ã¯åŠ›å°½ãã¦ã—ã¾ã„ã¾ã—ãŸ...</p>
                <button @click="resetGame" class="control-btn">ğŸ”„ ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    // ã‚²ãƒ¼ãƒ å®šæ•°
                    HEAL_COST: 50,
                    DUNGEON_REWARDS: { gold: 500, exp: 200 },
                    POTION_HEAL: { min: 20, max: 30 },
                    VIEW_RANGE: 2,
                    MAP_SIZE: 8,
                    INITIAL_POTIONS: 3,
                    MAX_MESSAGES: 10,
                    FLEE_SUCCESS_RATE: 0.7,
                    ITEM_DROP_RATE: 0.4,
                    
                    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
                    gameState: 'character-creation',
                    character: {
                        name: '',
                        level: 1,
                        exp: 0,
                        expToNext: 100,
                        hp: 50,
                        maxHp: 50,
                        attack: 10,
                        defense: 5,
                        gold: 0
                    },
                    
                    // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³çŠ¶æ…‹
                    currentFloor: 1,
                    playerX: 1,
                    playerY: 6,
                    potions: 3,
                    keys: 0,
                    messages: [],
                    currentEnemy: null,
                    doorStates: {},
                    chestStates: {},
                    visitedCells: {},
                    levelUpMessage: '',
                    lastReward: { gold: 0, exp: 0 },
                    
                    // å„éšå±¤ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®
                    playerPositions: {
                        1: { x: 1, y: 6 },
                        2: { x: 1, y: 1 },
                        3: { x: 1, y: 1 }
                    },
                    
                    // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ãƒãƒƒãƒ— (0:å£, 1:åºŠ, 2:æ•µ, 3:ã‚´ãƒ¼ãƒ«, 4:æ‰‰, 5:éµä»˜ãæ‰‰, 6:å®ç®±, 7:ä¸Šã‚Šéšæ®µ, 8:ä¸‹ã‚Šéšæ®µ)
                    dungeonMaps: {
                        1: [
                            [0,0,0,0,0,0,0,0],
                            [0,1,1,4,1,1,1,0],
                            [0,1,0,6,2,0,1,0],
                            [0,4,0,1,1,0,1,0],
                            [0,1,1,1,0,1,1,0],
                            [0,0,0,1,2,1,0,0],
                            [0,7,1,1,8,1,1,0],
                            [0,0,0,0,0,0,0,0]
                        ],
                        2: [
                            [0,0,0,0,0,0,0,0],
                            [0,7,1,1,1,1,1,0],
                            [0,1,0,6,2,0,1,0],
                            [0,1,0,1,5,0,4,0],
                            [0,1,1,1,0,1,1,0],
                            [0,0,6,1,2,1,0,0],
                            [0,1,1,1,8,1,1,0],
                            [0,0,0,0,0,0,0,0]
                        ],
                        3: [
                            [0,0,0,0,0,0,0,0],
                            [0,7,1,1,1,1,1,0],
                            [0,1,0,6,2,0,1,0],
                            [0,5,0,1,1,0,5,0],
                            [0,1,1,1,0,1,1,0],
                            [0,0,0,5,2,5,0,0],
                            [0,6,1,1,1,1,1,0],
                            [0,0,0,0,3,0,0,0]
                        ]
                    }
                }
            },
            
            computed: {
                canLevelUp() {
                    return Number(this.character.exp) >= Number(this.character.expToNext);
                },
                
                expNeeded() {
                    return Number(this.character.expToNext) - Number(this.character.exp);
                },
                
                canFullHeal() {
                    return this.character.hp < this.character.maxHp && this.character.gold >= this.HEAL_COST;
                },
                
                canUsePotion() {
                    return this.potions > 0 && this.character.hp < this.character.maxHp;
                },
                
                mapDisplay() {
                    const display = [];
                    
                    for (let dy = -this.VIEW_RANGE; dy <= this.VIEW_RANGE; dy++) {
                        for (let dx = -this.VIEW_RANGE; dx <= this.VIEW_RANGE; dx++) {
                            const x = this.playerX + dx;
                            const y = this.playerY + dy;
                            
                            if (dx === 0 && dy === 0) {
                                display.push('player');
                                continue;
                            }
                            
                            if (x < 0 || x >= this.MAP_SIZE || y < 0 || y >= this.MAP_SIZE) {
                                display.push('unknown');
                                continue;
                            }
                            
                            display.push(this.getCellType(x, y));
                        }
                    }
                    return display;
                },
                
                adjacentStairs() {
                    return this.findAdjacentCell([7, 8], (cell, x, y) => {
                        const isUp = cell === 7;
                        const isExit = this.currentFloor === 1 && isUp;
                        const canUse = isExit || (isUp ? this.currentFloor > 1 : this.currentFloor < 3);
                        
                        return { isUp, canUse, isExit };
                    });
                },
                
                adjacentDoor() {
                    return this.findAdjacentCell([4, 5], (cell, x, y) => {
                        const doorKey = `${this.currentFloor}-${x}-${y}`;
                        return {
                            x, y,
                            isOpen: this.doorStates[doorKey] || false,
                            isLocked: cell === 5,
                            key: doorKey
                        };
                    });
                },
                
                adjacentChest() {
                    return this.findAdjacentCell([6], (cell, x, y) => {
                        const chestKey = `${this.currentFloor}-${x}-${y}`;
                        return {
                            x, y,
                            isOpened: this.chestStates[chestKey] || false,
                            key: chestKey
                        };
                    });
                }
            },
            
            mounted() {
                this.rollStats();
            },
            
            methods: {
                // åˆæœŸåŒ–ãƒ»ã‚²ãƒ¼ãƒ é–‹å§‹
                rollStats() {
                    if (this.character.level === 1 && this.character.exp === 0) {
                        const baseHp = 40 + Math.floor(Math.random() * 21);
                        const baseAttack = 8 + Math.floor(Math.random() * 5);
                        const baseDefense = 3 + Math.floor(Math.random() * 5);
                        
                        this.character.hp = baseHp;
                        this.character.maxHp = baseHp;
                        this.character.attack = baseAttack;
                        this.character.defense = baseDefense;
                    }
                },
                
                startGame() {
                    if (!this.character.name.trim()) return;
                    this.gameState = 'town';
                    this.addMessage(`${this.character.name}ã•ã‚“ã€å†’é™ºè€…ã®ç”ºã¸ã‚ˆã†ã“ãï¼`);
                },
                
                // ç”ºãƒ»ã‚®ãƒ«ãƒ‰é–¢é€£
                enterGuild() {
                    this.gameState = 'guild';
                },
                
                leaveGuild() {
                    this.gameState = 'town';
                },
                
                enterDungeon() {
                    this.gameState = 'playing';
                    this.initializeDungeon();
                    this.addMessage(`${this.character.name}ãŒãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã«å…¥ã‚Šã¾ã—ãŸï¼`);
                    this.addMessage('3éšå»ºã¦ã®ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã§ã™ã€‚æœ€ä¸‹éšã«ã‚ã‚‹å®ç‰©ã‚’ç›®æŒ‡ã—ã¾ã—ã‚‡ã†ï¼');
                    this.addMessage('1éšã®ä¸Šã‚Šéšæ®µã‹ã‚‰ã„ã¤ã§ã‚‚ç”ºã«æˆ»ã‚Œã¾ã™ã€‚');
                },
                
                initializeDungeon() {
                    this.currentFloor = 1;
                    this.playerX = this.playerPositions[1].x;
                    this.playerY = this.playerPositions[1].y;
                    this.messages = [];
                },
                
                fullHeal() {
                    if (this.canFullHeal) {
                        this.character.gold = Number(this.character.gold) - this.HEAL_COST;
                        this.character.hp = this.character.maxHp;
                        this.addMessage('å®Œå…¨å›å¾©ã—ã¾ã—ãŸï¼');
                    }
                },
                
                levelUp() {
                    if (!this.canLevelUp) return;
                    
                    let totalLevelUps = 0;
                    let totalHpIncrease = 0;
                    let totalAttackIncrease = 0;
                    let totalDefenseIncrease = 0;
                    
                    while (Number(this.character.exp) >= Number(this.character.expToNext)) {
                        const increases = this.performSingleLevelUp();
                        totalLevelUps++;
                        totalHpIncrease += increases.hp;
                        totalAttackIncrease += increases.attack;
                        totalDefenseIncrease += increases.defense;
                    }
                    
                    this.setLevelUpMessage(totalLevelUps, totalHpIncrease, totalAttackIncrease, totalDefenseIncrease);
                },
                
                performSingleLevelUp() {
                    this.character.exp = Number(this.character.exp) - Number(this.character.expToNext);
                    this.character.level = Number(this.character.level) + 1;
                    
                    const hpIncrease = 8 + Math.floor(Math.random() * 5);
                    const attackIncrease = 2 + Math.floor(Math.random() * 3);
                    const defenseIncrease = 1 + Math.floor(Math.random() * 3);
                    
                    this.character.maxHp = Number(this.character.maxHp) + hpIncrease;
                    this.character.hp = Number(this.character.hp) + hpIncrease;
                    this.character.attack = Number(this.character.attack) + attackIncrease;
                    this.character.defense = Number(this.character.defense) + defenseIncrease;
                    
                    this.character.expToNext = Math.floor(100 * Math.pow(1.2, this.character.level - 1));
                    
                    return { hp: hpIncrease, attack: attackIncrease, defense: defenseIncrease };
                },
                
                setLevelUpMessage(levels, hp, attack, defense) {
                    if (levels === 1) {
                        this.levelUpMessage = `ãƒ¬ãƒ™ãƒ«${this.character.level}ã«ãªã‚Šã¾ã—ãŸï¼\nHP+${hp}, æ”»æ’ƒåŠ›+${attack}, é˜²å¾¡åŠ›+${defense}`;
                    } else {
                        this.levelUpMessage = `${levels}ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ãƒ¬ãƒ™ãƒ«${this.character.level}ã«ãªã‚Šã¾ã—ãŸï¼\nHP+${hp}, æ”»æ’ƒåŠ›+${attack}, é˜²å¾¡åŠ›+${defense}`;
                    }
                },
                
                // ç§»å‹•ãƒ»æ¢ç´¢
                move(direction) {
                    const { newX, newY } = this.getNewPosition(direction);
                    
                    if (!this.isValidPosition(newX, newY)) {
                        this.addMessage('ãã¡ã‚‰ã¯å£ã§ã™...');
                        return;
                    }
                    
                    const cell = this.dungeonMaps[this.currentFloor][newY][newX];
                    
                    if (!this.canMoveToCell(cell, newX, newY)) return;
                    
                    this.movePlayer(newX, newY);
                    this.handleCellEvent(cell);
                },
                
                getNewPosition(direction) {
                    const directions = {
                        'up': { x: 0, y: -1 },
                        'down': { x: 0, y: 1 },
                        'left': { x: -1, y: 0 },
                        'right': { x: 1, y: 0 }
                    };
                    
                    return {
                        newX: this.playerX + directions[direction].x,
                        newY: this.playerY + directions[direction].y
                    };
                },
                
                isValidPosition(x, y) {
                    return x >= 0 && x < this.MAP_SIZE && y >= 0 && y < this.MAP_SIZE && 
                           this.dungeonMaps[this.currentFloor][y][x] !== 0;
                },
                
                canMoveToCell(cell, x, y) {
                    if (cell === 4 || cell === 5) {
                        const doorKey = `${this.currentFloor}-${x}-${y}`;
                        if (!this.doorStates[doorKey]) {
                            this.addMessage('æ‰‰ãŒé–‰ã¾ã£ã¦ã„ã¾ã™ã€‚');
                            return false;
                        }
                    }
                    
                    if (cell === 6) {
                        this.addMessage('å®ç®±ãŒã‚ã‚‹ãŸã‚é€²ã‚ã¾ã›ã‚“ã€‚');
                        return false;
                    }
                    
                    if (cell === 7 || cell === 8) {
                        this.addMessage('éšæ®µãŒã‚ã‚Šã¾ã™ã€‚éšæ®µãƒœã‚¿ãƒ³ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚');
                        return false;
                    }
                    
                    return true;
                },
                
                movePlayer(x, y) {
                    this.playerX = x;
                    this.playerY = y;
                    this.playerPositions[this.currentFloor].x = x;
                    this.playerPositions[this.currentFloor].y = y;
                },
                
                handleCellEvent(cell) {
                    if (cell === 2) {
                        this.startCombat();
                    } else if (cell === 3) {
                        this.lastReward = { ...this.DUNGEON_REWARDS };
                        this.gameState = 'victory';
                    } else {
                        this.addMessage(`(${this.playerX}, ${this.playerY})ã«ç§»å‹•ã—ã¾ã—ãŸ`);
                    }
                },
                
                // éšæ®µãƒ»æ‰‰ãƒ»å®ç®±
                useStairs() {
                    if (!this.adjacentStairs || !this.adjacentStairs.canUse) return;
                    
                    if (this.adjacentStairs.isExit) {
                        this.gameState = 'town';
                        this.addMessage('ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‹ã‚‰ç”ºã«æˆ»ã‚Šã¾ã—ãŸã€‚');
                        return;
                    }
                    
                    this.currentFloor += this.adjacentStairs.isUp ? -1 : 1;
                    this.playerX = this.playerPositions[this.currentFloor].x;
                    this.playerY = this.playerPositions[this.currentFloor].y;
                    this.addMessage(`${this.currentFloor}éšã«ç§»å‹•ã—ã¾ã—ãŸã€‚`);
                },
                
                getStairsButtonText() {
                    if (!this.adjacentStairs) return '';
                    if (this.adjacentStairs.isExit) return 'ğŸ˜ï¸ ç”ºã«æˆ»ã‚‹';
                    return this.adjacentStairs.isUp ? 'â¬†ï¸ ä¸Šã®éšã«è¡Œã' : 'â¬‡ï¸ ä¸‹ã®éšã«è¡Œã';
                },
                
                openDoor() {
                    if (this.adjacentDoor && !this.adjacentDoor.isOpen && !this.adjacentDoor.isLocked) {
                        this.doorStates[this.adjacentDoor.key] = true;
                        this.addMessage('æ‰‰ã‚’é–‹ã‘ã¾ã—ãŸã€‚');
                    }
                },
                
                unlockDoor() {
                    if (this.adjacentDoor && !this.adjacentDoor.isOpen && this.adjacentDoor.isLocked && this.keys > 0) {
                        this.keys--;
                        this.doorStates[this.adjacentDoor.key] = true;
                        this.addMessage(`éµã‚’ä½¿ã£ã¦æ‰‰ã‚’é–‹ã‘ã¾ã—ãŸï¼æ®‹ã‚Š${this.keys}å€‹`);
                    }
                },
                
                openChest() {
                    if (!this.adjacentChest || this.adjacentChest.isOpened) return;
                    
                    this.chestStates[this.adjacentChest.key] = true;
                    const treasure = this.generateTreasure();
                    
                    this.addMessage('å®ç®±ã‚’é–‹ã‘ã¾ã—ãŸï¼');
                    this.addMessage(treasure.message);
                    
                    if (treasure.type === 'key') this.keys++;
                    if (treasure.type === 'potion') this.potions++;
                },
                
                generateTreasure() {
                    const treasures = [
                        { type: 'key', message: 'âœ¨ éµã‚’è¦‹ã¤ã‘ã¾ã—ãŸï¼' },
                        { type: 'potion', message: 'âœ¨ å›å¾©è–¬ã‚’è¦‹ã¤ã‘ã¾ã—ãŸï¼' },
                        { type: 'nothing', message: 'å®ç®±ã¯ç©ºã§ã—ãŸ...' }
                    ];
                    return treasures[Math.floor(Math.random() * treasures.length)];
                },
                
                // æˆ¦é—˜ã‚·ã‚¹ãƒ†ãƒ 
                startCombat() {
                    const enemies = [
                        { name: 'ã‚¹ãƒ©ã‚¤ãƒ ', hp: 20, maxHp: 20, attack: 6, expReward: { min: 5, max: 10 }, goldReward: { min: 3, max: 8 } },
                        { name: 'ã‚´ãƒ–ãƒªãƒ³', hp: 30, maxHp: 30, attack: 8, expReward: { min: 10, max: 15 }, goldReward: { min: 8, max: 15 } },
                        { name: 'ã‚ªãƒ¼ã‚¯', hp: 40, maxHp: 40, attack: 10, expReward: { min: 15, max: 25 }, goldReward: { min: 15, max: 25 } }
                    ];
                    
                    this.currentEnemy = { ...enemies[Math.floor(Math.random() * enemies.length)] };
                    this.gameState = 'combat';
                    this.addMessage(`${this.currentEnemy.name}ã¨é­é‡ï¼`);
                },
                
                attack() {
                    const playerDamage = Math.max(1, this.character.attack - Math.floor(Math.random() * 3));
                    this.currentEnemy.hp = Math.max(0, this.currentEnemy.hp - playerDamage);
                    this.addMessage(`${this.currentEnemy.name}ã«${playerDamage}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
                    
                    if (this.currentEnemy.hp <= 0) {
                        this.handleEnemyDefeated();
                        return;
                    }
                    
                    this.handleEnemyAttack();
                },
                
                handleEnemyDefeated() {
                    this.addMessage(`${this.currentEnemy.name}ã‚’å€’ã—ã¾ã—ãŸï¼`);
                    
                    // EXPã¨é‡‘ã®ç²å¾—
                    const expGained = this.getRandomReward(this.currentEnemy.expReward);
                    const goldGained = this.getRandomReward(this.currentEnemy.goldReward);
                    
                    this.character.exp = Number(this.character.exp) + expGained;
                    this.character.gold = Number(this.character.gold) + goldGained;
                    
                    this.addMessage(`${expGained}EXPã€${goldGained}G ã‚’ç²å¾—ï¼`);
                    
                    // ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ­ãƒƒãƒ—
                    if (Math.random() < this.ITEM_DROP_RATE) {
                        this.potions++;
                        this.addMessage('å›å¾©è–¬ã‚’è¦‹ã¤ã‘ã¾ã—ãŸï¼');
                    }
                    
                    this.dungeonMaps[this.currentFloor][this.playerY][this.playerX] = 1;
                    this.gameState = 'playing';
                },
                
                handleEnemyAttack() {
                    const enemyDamage = Math.max(1, this.currentEnemy.attack - this.character.defense);
                    this.character.hp = Math.max(0, this.character.hp - enemyDamage);
                    this.addMessage(`${enemyDamage}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã—ãŸï¼`);
                    
                    if (this.character.hp <= 0) {
                        this.gameState = 'game-over';
                    }
                },
                
                flee() {
                    if (Math.random() < this.FLEE_SUCCESS_RATE) {
                        this.addMessage('é€ƒã’å‡ºã—ã¾ã—ãŸï¼');
                        this.gameState = 'playing';
                        if (this.playerX > 0) this.playerX--;
                    } else {
                        this.addMessage('é€ƒã’ã‚‰ã‚Œã¾ã›ã‚“ã§ã—ãŸï¼');
                        this.handleEnemyAttack();
                    }
                },
                
                // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨
                usePotion() {
                    if (!this.canUsePotion) return;
                    
                    this.potions--;
                    const healAmount = this.POTION_HEAL.min + Math.floor(Math.random() * (this.POTION_HEAL.max - this.POTION_HEAL.min + 1));
                    this.character.hp = Math.min(this.character.maxHp, this.character.hp + healAmount);
                    this.addMessage(`${healAmount}HPå›å¾©ã—ã¾ã—ãŸï¼`);
                },
                
                // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒ»ãƒªã‚»ãƒƒãƒˆ
                returnToTown() {
                    this.character.gold = Number(this.character.gold) + Number(this.lastReward.gold);
                    this.character.exp = Number(this.character.exp) + Number(this.lastReward.exp);
                    this.character.hp = this.character.maxHp;
                    
                    this.resetDungeon();
                    this.gameState = 'town';
                    this.addMessage(`ç”ºã«æˆ»ã‚Šã¾ã—ãŸã€‚å ±é…¬: ${this.lastReward.gold}G, ${this.lastReward.exp}EXP`);
                },
                
                resetGame() {
                    this.gameState = 'character-creation';
                    this.character = {
                        name: '',
                        level: 1,
                        exp: 0,
                        expToNext: 100,
                        hp: 50,
                        maxHp: 50,
                        attack: 10,
                        defense: 5,
                        gold: 0
                    };
                    this.levelUpMessage = '';
                    this.lastReward = { gold: 0, exp: 0 };
                    this.resetDungeon();
                },
                
                resetDungeon() {
                    this.currentFloor = 1;
                    this.playerX = 1;
                    this.playerY = 6;
                    this.potions = this.INITIAL_POTIONS;
                    this.keys = 0;
                    this.messages = [];
                    this.currentEnemy = null;
                    this.doorStates = {};
                    this.chestStates = {};
                    this.visitedCells = {};
                    
                    this.playerPositions = {
                        1: { x: 1, y: 6 },
                        2: { x: 1, y: 1 },
                        3: { x: 1, y: 1 }
                    };
                    
                    this.resetDungeonMaps();
                },
                
                resetDungeonMaps() {
                    this.dungeonMaps = {
                        1: [
                            [0,0,0,0,0,0,0,0],
                            [0,1,1,4,1,1,1,0],
                            [0,1,0,6,2,0,1,0],
                            [0,4,0,1,1,0,1,0],
                            [0,1,1,1,0,1,1,0],
                            [0,0,0,1,2,1,0,0],
                            [0,7,1,1,8,1,1,0],
                            [0,0,0,0,0,0,0,0]
                        ],
                        2: [
                            [0,0,0,0,0,0,0,0],
                            [0,7,1,1,1,1,1,0],
                            [0,1,0,6,2,0,1,0],
                            [0,1,0,1,5,0,4,0],
                            [0,1,1,1,0,1,1,0],
                            [0,0,6,1,2,1,0,0],
                            [0,1,1,1,8,1,1,0],
                            [0,0,0,0,0,0,0,0]
                        ],
                        3: [
                            [0,0,0,0,0,0,0,0],
                            [0,7,1,1,1,1,1,0],
                            [0,1,0,6,2,0,1,0],
                            [0,5,0,1,1,0,5,0],
                            [0,1,1,1,0,1,1,0],
                            [0,0,0,5,2,5,0,0],
                            [0,6,1,1,1,1,1,0],
                            [0,0,0,0,3,0,0,0]
                        ]
                    };
                },
                
                // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
                getRandomReward(rewardRange) {
                    return rewardRange.min + Math.floor(Math.random() * (rewardRange.max - rewardRange.min + 1));
                },
                
                getCellType(x, y) {
                    const cell = this.dungeonMaps[this.currentFloor][y][x];
                    
                    if (cell === 0) return 'wall';
                    if (cell === 1 || cell === 2) return 'floor';
                    if (cell === 3) return 'goal';
                    if (cell === 4) {
                        const doorKey = `${this.currentFloor}-${x}-${y}`;
                        return this.doorStates[doorKey] ? 'door-open' : 'door-closed';
                    }
                    if (cell === 5) {
                        const doorKey = `${this.currentFloor}-${x}-${y}`;
                        return this.doorStates[doorKey] ? 'door-open' : 'door-locked';
                    }
                    if (cell === 6) {
                        const chestKey = `${this.currentFloor}-${x}-${y}`;
                        return this.chestStates[chestKey] ? 'treasure-opened' : 'treasure-chest';
                    }
                    if (cell === 7) return 'stairs-up';
                    if (cell === 8) return 'stairs-down';
                    
                    return 'floor';
                },
                
                findAdjacentCell(cellTypes, dataFactory) {
                    const directions = [
                        { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
                    ];
                    
                    for (let dir of directions) {
                        const x = this.playerX + dir.dx;
                        const y = this.playerY + dir.dy;
                        
                        if (x >= 0 && x < this.MAP_SIZE && y >= 0 && y < this.MAP_SIZE) {
                            const cell = this.dungeonMaps[this.currentFloor][y][x];
                            if (cellTypes.includes(cell)) {
                                return dataFactory(cell, x, y);
                            }
                        }
                    }
                    return null;
                },
                
                getCellClass(cell) {
                    return cell;
                },
                
                getCellSymbol(cell) {
                    const symbols = {
                        'wall': 'â–ˆ',
                        'floor': 'Â·',
                        'player': '@',
                        'enemy': 'M',
                        'goal': 'â˜…',
                        'unknown': '?',
                        'visited': 'Â·',
                        'door-closed': 'â”ƒ',
                        'door-open': 'â•±',
                        'door-locked': 'ğŸ”’',
                        'treasure-chest': 'ğŸ“¦',
                        'treasure-opened': 'ğŸ“­',
                        'stairs-up': 'â¬†ï¸',
                        'stairs-down': 'â¬‡ï¸'
                    };
                    return symbols[cell] || ' ';
                },
                
                addMessage(text) {
                    this.messages.push(text);
                    if (this.messages.length > this.MAX_MESSAGES) {
                        this.messages.shift();
                    }
                    
                    this.$nextTick(() => {
                        const log = document.querySelector('.message-log');
                        if (log) log.scrollTop = log.scrollHeight;
                    });
                }
            }
        }).mount('#app');
    </script>
</body>
</html>